record(bo, "$(P)SIM")
{
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(ZNAM, "NO")
  field(ONAM, "YES")
  field(VAL, "$(RECSIM=0)")
}

# Separator Voltage

record(ai, "$(P)VOLT")
{
  field(DESC, "Voltage")
  field(EGU, "kV")
  field(HIGH,  "210") # Magic number is DAQ max volt + 5%
  field(LOW,  "-5") # Magic number is DAQ min volt - 5%
  field(HSV,  "MINOR")
  field(LSV,  "MINOR")
  field(DTYP, "Soft Channel")
  field(INP,  "$(P)CALIBRATE:VOLT CP MS") # input from DATA
  field(PREC, "5")
  info(INTEREST, "HIGH")
  info(archive, "VAL")
    field(TPRO, "1")
}

record(calc, "$(P)CALIBRATE:VOLT")
{
    field(DESC, "Calibrates the voltage")
    # Recsim testing here because simulating a waveform and an I/O Intr is very
    # difficult. This is the deepest level that can be tested without
    # significant effort/restructuring
    $(IFNOTRECSIM) field(INPA, "$(DAQMX):VOLT:DATA CP MS")
    $(IFRECSIM) field(INPA, "$(DAQMX):VOLT:SIM CP MS")
    field(CALC, "A * $(PSU_MAX_VOLT) / 10")
    field(PREC, "5")
}

record(subArray, "$(DAQMX):VOLT:DATA")
{
  field(PINI, "NO")
  field(DTYP, "Soft Channel")
  field(PREC, "5")
  field(INP, "$(DAQMX):VOLT:_RAW CP MS")
  field(NELM, "1") # 1 Element
  field(INDX, "0")
  field(FTVL, "DOUBLE")
    field(TPRO, "1")
}

record(waveform, "$(DAQMX):VOLT:_RAW")
{
  $(IFNOTRECSIM) field(SCAN,"I/O Intr")
  #field(SCAN,  ".5 second")
  #field(SCAN,".5 second")
  field(PINI, "NO")
  $(IFNOTRECSIM)  field(DTYP, "asynFloat64ArrayIn")
  $(IFRECSIM) field(DTYP, "Soft Channel")
  field(PREC, "5")
  field(INP, "@asyn(R0 2 5.0) DATA")
  field(NELM, "1000")
  field(FTVL, "DOUBLE")
  field(EVNT, "1")
  field(SIML, "$(P)SIM")
  field(SIOL, "$(DAQMX):VOLT:WV:SIM CP")
  field(TPRO, "1")
  field(FLNK, "$(DAQMX):VOLT:CALC")
}

record(waveform,  "$(DAQMX):VOLT:WV:SIM")
{
  field(DESC,  "Voltage simulation")
  field(NELM,  "1")
  field(FTVL,  "DOUBLE")
    field(TPRO, "1")
}

record(acalcout, "$(DAQMX):SIM:CALC")
{
  field(DESC, "Converts voltage to waveform")
  field(INPA, "$(DAQMX):VOLT:SIM CP")
  field(CALC, "ARR(A)")

  field(OOPT, "Every Time")
  field(OUT, "$(DAQMX):VOLT:WV:SIM PP")
  field(DOPT, "Use CALC")
    field(TPRO, "1")
}

record(calcout, "$(DAQMX):VOLT:ACQUIRE:_TRIG")
{
  field(INPA, "$(DAQMX):VOLT:ACQUIRE.VAL CP MS")
  field(CALC, "!A")
  field(OUT, "$(DAQMX):VOLT:ACQUIRE.VAL PP")
  field(OOPT, "When Non-zero")
}

record(longout, "$(DAQMX):VOLT:ACQUIRE")
{
  field(SCAN, ".5 second")
  field(DTYP, "asynUInt32Digital")
  field(OUT, "@asynMask(R0 2 0x01) ACQUIRE")
  field(TPRO, "1")
}


####################################
####### Setting the voltage ########
####################################

record(ao, "$(P)VOLT:SP")
{
  field(DESC, "Voltage set point")
  field(EGU, "kV")
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(PREC, "2")
}

record(calcout, "$(P)CALIBRATE:VOLT:SP")
{
  field(IVOA, "Don't drive outputs")
  field(DESC, "Calibrates the voltage setpoint")
  field(INPA, "$(P)VOLT:SP CP MS")
  field(CALC, "(A * 10) / $(PSU_MAX_VOLT)")
  field(PREC, "5")
  field(OUT, "$(DAQMX):VOLT:SP:DATA PP")
}

record(ao, "$(DAQMX):VOLT:SP:DATA")
{
  $(IFNOTRECSIM)  field(DTYP, "asynFloat64")
  $(IFRECSIM) field(DTYP, "Soft Channel")

  field(OUT, "@asyn(W0, 2, 5.0) DATA")
  field(PREC, "5")
  field(SIML, "$(P)SIM")
  field(SIOL, "$(DAQMX):VOLT:SIM")
}

record(ai, "$(DAQMX):VOLT:SIM")
{
  field(INP, "$(DAQMX):VOLT:SP:DATA CP")
  field(DESC, "Device voltage")
  field(DTYP, "Soft Channel")
  field(PREC, "5")
    field(TPRO, "1")
}

###### NOT NEEDED PROBABLY
# record(calcout, "$(DAQMX):VOLT:SP:CALC")
# {
#   field(DESC, "Sends 1 to ACQUIRE when triggered")
#   field(CALC, "1")
#   field(OOPT, "Every Time")
#   field(OUT, "$(DAQMX):VOLT:SP:ACQUIRE PP")
#   field(TPRO, "1")
# }
#
# record(bo, "$(DAQMX):VOLT:SP:ACQUIRE")
# {
#   field(SCAN, "Passive")
#   field(PINI, "NO")
#   field(DTYP, "asynUInt32Digital")
#   field(OUT, "@asynMask(W0 2 0x01) ACQUIRE")
#   field(ZNAM, "stop")
#   field(ONAM, "run")
# }
